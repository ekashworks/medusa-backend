"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@medusajs/utils");
const typeorm_1 = require("typeorm");
const models_1 = require("../models");
const build_query_1 = require("../utils/build-query");
class ReservationItemService {
    constructor({ eventBusService, inventoryLevelService, manager, }) {
        this.manager_ = manager;
        this.eventBusService_ = eventBusService;
        this.inventoryLevelService_ = inventoryLevelService;
    }
    /**
     * Lists reservation items that match the provided filter.
     * @param selector - Filters to apply to the reservation items.
     * @param config - Configuration for the query.
     * @param context
     * @return Array of reservation items that match the selector.
     */
    async list(selector = {}, config = { relations: [], skip: 0, take: 10 }, context = {}) {
        const manager = context.transactionManager ?? this.manager_;
        const itemRepository = manager.getRepository(models_1.ReservationItem);
        const query = (0, build_query_1.buildQuery)(selector, config);
        return await itemRepository.find(query);
    }
    /**
     * Lists reservation items that match the provided filter and returns the total count.
     * @param selector - Filters to apply to the reservation items.
     * @param config - Configuration for the query.
     * @param context
     * @return Array of reservation items that match the selector and the total count.
     */
    async listAndCount(selector = {}, config = { relations: [], skip: 0, take: 10 }, context = {}) {
        const manager = context.transactionManager ?? this.manager_;
        const itemRepository = manager.getRepository(models_1.ReservationItem);
        const query = (0, build_query_1.buildQuery)(selector, config);
        return await itemRepository.findAndCount(query);
    }
    /**
     * Retrieves a reservation item by its id.
     * @param reservationItemId - The id of the reservation item to retrieve.
     * @param config - Configuration for the query.
     * @param context
     * @return The reservation item with the provided id.
     * @throws If reservationItemId is not defined or if the reservation item was not found.
     */
    async retrieve(reservationItemId, config = {}, context = {}) {
        if (!(0, utils_1.isDefined)(reservationItemId)) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `"reservationItemId" must be defined`);
        }
        const manager = context.transactionManager ?? this.manager_;
        const reservationItemRepository = manager.getRepository(models_1.ReservationItem);
        const query = (0, build_query_1.buildQuery)({ id: reservationItemId }, config);
        const [reservationItem] = await reservationItemRepository.find(query);
        if (!reservationItem) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `ReservationItem with id ${reservationItemId} was not found`);
        }
        return reservationItem;
    }
    /**
     * Create a new reservation item.
     * @param data - The reservation item data.
     * @param context
     * @return The created reservation item.
     */
    async create(data, context = {}) {
        const manager = context.transactionManager;
        const reservationItemRepository = manager.getRepository(models_1.ReservationItem);
        const reservationItems = reservationItemRepository.create(data.map((tc) => ({
            inventory_item_id: tc.inventory_item_id,
            line_item_id: tc.line_item_id,
            location_id: tc.location_id,
            quantity: tc.quantity,
            metadata: tc.metadata,
            external_id: tc.external_id,
            description: tc.description,
            created_by: tc.created_by,
        })));
        const [newReservationItems] = await (0, utils_1.promiseAll)([
            reservationItemRepository.save(reservationItems),
            ...data.map(async (data) => 
            // TODO make bulk
            await this.inventoryLevelService_.adjustReservedQuantity(data.inventory_item_id, data.location_id, data.quantity, context)),
        ]);
        await this.eventBusService_?.emit?.(ReservationItemService.Events.CREATED, {
            ids: newReservationItems.map((i) => i.id),
        });
        return newReservationItems;
    }
    /**
     * Update a reservation item.
     * @param reservationItemId - The reservation item's id.
     * @param data - The reservation item data to update.
     * @param context
     * @return The updated reservation item.
     */
    async update(reservationItemId, data, context = {}) {
        const manager = context.transactionManager;
        const itemRepository = manager.getRepository(models_1.ReservationItem);
        const item = await this.retrieve(reservationItemId, undefined, context);
        const shouldUpdateQuantity = (0, utils_1.isDefined)(data.quantity) && data.quantity !== item.quantity;
        const shouldUpdateLocation = (0, utils_1.isDefined)(data.location_id) && data.location_id !== item.location_id;
        const ops = [];
        if (shouldUpdateLocation) {
            ops.push(this.inventoryLevelService_.adjustReservedQuantity(item.inventory_item_id, item.location_id, item.quantity * -1, context), this.inventoryLevelService_.adjustReservedQuantity(item.inventory_item_id, data.location_id, data.quantity || item.quantity, context));
        }
        else if (shouldUpdateQuantity) {
            const quantityDiff = data.quantity - item.quantity;
            ops.push(this.inventoryLevelService_.adjustReservedQuantity(item.inventory_item_id, item.location_id, quantityDiff, context));
        }
        const mergedItem = itemRepository.merge(item, data);
        ops.push(itemRepository.save(item));
        await (0, utils_1.promiseAll)(ops);
        await this.eventBusService_?.emit?.(ReservationItemService.Events.UPDATED, {
            id: mergedItem.id,
        });
        return mergedItem;
    }
    /**
     * Deletes a reservation item by line item id.
     * @param lineItemId - the id of the line item to delete.
     * @param context
     */
    async deleteByLineItem(lineItemId, context = {}) {
        const manager = context.transactionManager;
        const itemRepository = manager.getRepository(models_1.ReservationItem);
        const lineItemIds = Array.isArray(lineItemId) ? lineItemId : [lineItemId];
        const reservationItems = await this.list({ line_item_id: lineItemIds }, undefined, context);
        const ops = [
            itemRepository.softDelete({ line_item_id: (0, typeorm_1.In)(lineItemIds) }),
        ];
        for (const reservation of reservationItems) {
            ops.push(this.inventoryLevelService_.adjustReservedQuantity(reservation.inventory_item_id, reservation.location_id, reservation.quantity * -1, context));
        }
        await (0, utils_1.promiseAll)(ops);
        await this.eventBusService_?.emit?.(ReservationItemService.Events.DELETED, {
            line_item_id: lineItemId,
        });
    }
    /**
     * Deletes reservation items by location ID.
     * @param locationId - The ID of the location to delete reservations for.
     * @param context
     */
    async deleteByLocationId(locationId, context = {}) {
        const manager = context.transactionManager;
        const itemRepository = manager.getRepository(models_1.ReservationItem);
        const ids = Array.isArray(locationId) ? locationId : [locationId];
        await itemRepository.softDelete({ location_id: (0, typeorm_1.In)(ids) });
        await this.eventBusService_?.emit?.(ReservationItemService.Events.DELETED, {
            location_id: locationId,
        });
    }
    /**
     * Deletes a reservation item by id.
     * @param reservationItemId - the id of the reservation item to delete.
     * @param context
     */
    async delete(reservationItemId, context = {}) {
        const ids = Array.isArray(reservationItemId)
            ? reservationItemId
            : [reservationItemId];
        const manager = context.transactionManager;
        const itemRepository = manager.getRepository(models_1.ReservationItem);
        const items = await this.list({ id: ids }, undefined, context);
        const promises = items.map(async (item) => {
            await this.inventoryLevelService_.adjustReservedQuantity(item.inventory_item_id, item.location_id, item.quantity * -1, context);
        });
        promises.push(itemRepository.softRemove(items));
        await (0, utils_1.promiseAll)(promises);
        await this.eventBusService_?.emit?.(ReservationItemService.Events.DELETED, {
            ids: reservationItemId,
        });
    }
}
ReservationItemService.Events = {
    CREATED: "reservation-item.created",
    UPDATED: "reservation-item.updated",
    DELETED: "reservation-item.deleted",
};
exports.default = ReservationItemService;
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ReservationItemService.prototype, "list", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], ReservationItemService.prototype, "listAndCount", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], ReservationItemService.prototype, "retrieve", null);
__decorate([
    (0, utils_1.InjectEntityManager)(),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], ReservationItemService.prototype, "create", null);
__decorate([
    (0, utils_1.InjectEntityManager)(),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], ReservationItemService.prototype, "update", null);
__decorate([
    (0, utils_1.InjectEntityManager)(),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], ReservationItemService.prototype, "deleteByLineItem", null);
__decorate([
    (0, utils_1.InjectEntityManager)(),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], ReservationItemService.prototype, "deleteByLocationId", null);
__decorate([
    (0, utils_1.InjectEntityManager)(),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], ReservationItemService.prototype, "delete", null);
//# sourceMappingURL=reservation-item.js.map