"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@medusajs/types");
const utils_1 = require("@medusajs/utils");
const joiner_config_1 = require("../joiner-config");
class InventoryService {
    constructor({ manager, inventoryItemService, inventoryLevelService, reservationItemService, }, options, moduleDeclaration) {
        this.moduleDeclaration = moduleDeclaration;
        this.manager_ = manager;
        this.inventoryItemService_ = inventoryItemService;
        this.inventoryLevelService_ = inventoryLevelService;
        this.reservationItemService_ = reservationItemService;
    }
    __joinerConfig() {
        return joiner_config_1.joinerConfig;
    }
    /**
     * Lists inventory items that match the given selector
     * @param selector - the selector to filter inventory items by
     * @param config - the find configuration to use
     * @param context
     * @return A tuple of inventory items and their total count
     */
    async listInventoryItems(selector, config = { relations: [], skip: 0, take: 10 }, context = {}) {
        return await this.inventoryItemService_.listAndCount(selector, config, context);
    }
    async list(selector, config = { relations: [], skip: 0, take: 10 }, context = {}) {
        return await this.inventoryItemService_.list(selector, config, context);
    }
    /**
     * Lists inventory levels that match the given selector
     * @param selector - the selector to filter inventory levels by
     * @param config - the find configuration to use
     * @param context
     * @return A tuple of inventory levels and their total count
     */
    async listInventoryLevels(selector, config = {
        relations: [],
        skip: 0,
        take: 10,
    }, context = {}) {
        return await this.inventoryLevelService_.listAndCount(selector, config, context);
    }
    /**
     * Lists reservation items that match the given selector
     * @param selector - the selector to filter reservation items by
     * @param config - the find configuration to use
     * @param context
     * @return A tuple of reservation items and their total count
     */
    async listReservationItems(selector, config = {
        relations: [],
        skip: 0,
        take: 10,
    }, context = {}) {
        return await this.reservationItemService_.listAndCount(selector, config, context);
    }
    /**
     * Retrieves an inventory item with the given id
     * @param inventoryItemId - the id of the inventory item to retrieve
     * @param config - the find configuration to use
     * @param context
     * @return The retrieved inventory item
     */
    async retrieveInventoryItem(inventoryItemId, config, context = {}) {
        const inventoryItem = await this.inventoryItemService_.retrieve(inventoryItemId, config, context);
        return { ...inventoryItem };
    }
    /**
     * Retrieves an inventory level for a given inventory item and location
     * @param inventoryItemId - the id of the inventory item
     * @param locationId - the id of the location
     * @param context
     * @return the retrieved inventory level
     */
    async retrieveInventoryLevel(inventoryItemId, locationId, context = {}) {
        const [inventoryLevel] = await this.inventoryLevelService_.list({ inventory_item_id: inventoryItemId, location_id: locationId }, { take: 1 }, context);
        if (!inventoryLevel) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `Inventory level for item ${inventoryItemId} and location ${locationId} not found`);
        }
        return inventoryLevel;
    }
    /**
     * Retrieves a reservation item
     * @param reservationId
     * @param context
     * @param reservationId
     * @param context
     */
    async retrieveReservationItem(reservationId, context = {}) {
        return await this.reservationItemService_.retrieve(reservationId, undefined, context);
    }
    async ensureInventoryLevels(data, context = {}) {
        const inventoryLevels = await this.inventoryLevelService_.list({
            inventory_item_id: data.map((e) => e.inventory_item_id),
            location_id: data.map((e) => e.location_id),
        }, {}, context);
        const inventoryLevelMap = inventoryLevels.reduce((acc, curr) => {
            const inventoryLevelMap = acc.get(curr.inventory_item_id) ?? new Map();
            inventoryLevelMap.set(curr.location_id, curr);
            acc.set(curr.inventory_item_id, inventoryLevelMap);
            return acc;
        }, new Map());
        const missing = data.filter((i) => !inventoryLevelMap.get(i.inventory_item_id)?.get(i.location_id));
        if (missing.length) {
            const error = missing
                .map((missing) => {
                return `Item ${missing.inventory_item_id} is not stocked at location ${missing.location_id}`;
            })
                .join(", ");
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, error);
        }
        return inventoryLevels.map((i) => inventoryLevelMap.get(i.inventory_item_id).get(i.location_id));
    }
    async createReservationItems(input, context = {}) {
        await this.ensureInventoryLevels(input, context);
        return await this.reservationItemService_.create(input, context);
    }
    /**
     * Creates a reservation item
     * @param input - the input object
     * @return The created reservation item
     */
    async createReservationItem(input, context = {}) {
        const [result] = await this.createReservationItems([input], context);
        return result;
    }
    async createInventoryItems(input, context = {}) {
        return await this.inventoryItemService_.create(input, context);
    }
    /**
     * Creates an inventory item
     * @param input - the input object
     * @param context
     * @return The created inventory item
     */
    async createInventoryItem(input, context = {}) {
        const [result] = await this.createInventoryItems([input], context);
        return result;
    }
    async createInventoryLevels(input, context = {}) {
        return await this.inventoryLevelService_.create(input, context);
    }
    /**
     * Creates an inventory item
     * @param input - the input object
     * @param context
     * @return The created inventory level
     */
    async createInventoryLevel(input, context = {}) {
        const [result] = await this.createInventoryLevels([input], context);
        return result;
    }
    /**
     * Updates an inventory item
     * @param inventoryItemId - the id of the inventory item to update
     * @param input - the input object
     * @param context
     * @return The updated inventory item
     */
    async updateInventoryItem(inventoryItemId, input, context = {}) {
        const inventoryItem = await this.inventoryItemService_.update(inventoryItemId, input, context);
        return { ...inventoryItem };
    }
    /**
     * Deletes an inventory item
     * @param inventoryItemId - the id of the inventory item to delete
     * @param context
     */
    async deleteInventoryItem(inventoryItemId, context = {}) {
        await this.inventoryLevelService_.deleteByInventoryItemId(inventoryItemId, context);
        return await this.inventoryItemService_.delete(inventoryItemId, context);
    }
    /**
     * Restore an inventory item and levels
     * @param inventoryItemId - the id of the inventory item to delete
     * @param context
     */
    async restoreInventoryItem(inventoryItemId, context = {}) {
        await this.inventoryLevelService_.restoreByInventoryItemId(inventoryItemId, context);
        return await this.inventoryItemService_.restore(inventoryItemId, context);
    }
    async deleteInventoryItemLevelByLocationId(locationId, context = {}) {
        return await this.inventoryLevelService_.deleteByLocationId(locationId, context);
    }
    async deleteReservationItemByLocationId(locationId, context = {}) {
        return await this.reservationItemService_.deleteByLocationId(locationId, context);
    }
    /**
     * Deletes an inventory level
     * @param inventoryItemId - the id of the inventory item associated with the level
     * @param locationId - the id of the location associated with the level
     * @param context
     */
    async deleteInventoryLevel(inventoryItemId, locationId, context = {}) {
        const [inventoryLevel] = await this.inventoryLevelService_.list({ inventory_item_id: inventoryItemId, location_id: locationId }, { take: 1 }, context);
        if (!inventoryLevel) {
            return;
        }
        return await this.inventoryLevelService_.delete(inventoryLevel.id, context);
    }
    async updateInventoryLevels(updates, context) {
        const inventoryLevels = await this.ensureInventoryLevels(updates);
        const levelMap = inventoryLevels.reduce((acc, curr) => {
            const inventoryLevelMap = acc.get(curr.inventory_item_id) ?? new Map();
            inventoryLevelMap.set(curr.location_id, curr.id);
            acc.set(curr.inventory_item_id, inventoryLevelMap);
            return acc;
        }, new Map());
        return await (0, utils_1.promiseAll)(updates.map(async (update) => {
            const levelId = levelMap
                .get(update.inventory_item_id)
                .get(update.location_id);
            // TODO make this bulk
            return this.inventoryLevelService_.update(levelId, update, context);
        }));
    }
    /**
     * Updates an inventory level
     * @param inventoryItemId - the id of the inventory item associated with the level
     * @param locationId - the id of the location associated with the level
     * @param input - the input object
     * @param context
     * @return The updated inventory level
     */
    async updateInventoryLevel(inventoryItemId, locationIdOrContext, input, context = {}) {
        const updates = [
            {
                inventory_item_id: inventoryItemId,
                location_id: locationIdOrContext,
                ...input,
            },
        ];
        const [result] = await this.updateInventoryLevels(updates, context);
        return result;
    }
    /**
     * Updates a reservation item
     * @param reservationItemId
     * @param input - the input object
     * @param context
     * @param context
     * @return The updated inventory level
     */
    async updateReservationItem(reservationItemId, input, context = {}) {
        return await this.reservationItemService_.update(reservationItemId, input, context);
    }
    /**
     * Deletes reservation items by line item
     * @param lineItemId - the id of the line item associated with the reservation item
     * @param context
     */
    async deleteReservationItemsByLineItem(lineItemId, context = {}) {
        return await this.reservationItemService_.deleteByLineItem(lineItemId, context);
    }
    /**
     * Deletes a reservation item
     * @param reservationItemId - the id of the reservation item to delete
     * @param context
     */
    async deleteReservationItem(reservationItemId, context = {}) {
        return await this.reservationItemService_.delete(reservationItemId, context);
    }
    /**
     * Adjusts the inventory level for a given inventory item and location.
     * @param inventoryItemId - the id of the inventory item
     * @param locationId - the id of the location
     * @param adjustment - the number to adjust the inventory by (can be positive or negative)
     * @param context
     * @return The updated inventory level
     * @throws when the inventory level is not found
     */
    async adjustInventory(inventoryItemId, locationId, adjustment, context = {}) {
        const [inventoryLevel] = await this.inventoryLevelService_.list({ inventory_item_id: inventoryItemId, location_id: locationId }, { take: 1 }, context);
        if (!inventoryLevel) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `Inventory level for inventory item ${inventoryItemId} and location ${locationId} not found`);
        }
        const updatedInventoryLevel = await this.inventoryLevelService_.update(inventoryLevel.id, {
            stocked_quantity: inventoryLevel.stocked_quantity + adjustment,
        }, context);
        return { ...updatedInventoryLevel };
    }
    /**
     * Retrieves the available quantity of a given inventory item in a given location.
     * @param inventoryItemId - the id of the inventory item
     * @param locationIds - the ids of the locations to check
     * @param context
     * @return The available quantity
     * @throws when the inventory item is not found
     */
    async retrieveAvailableQuantity(inventoryItemId, locationIds, context = {}) {
        // Throws if item does not exist
        await this.inventoryItemService_.retrieve(inventoryItemId, {
            select: ["id"],
        }, context);
        if (locationIds.length === 0) {
            return 0;
        }
        const availableQuantity = await this.inventoryLevelService_.getAvailableQuantity(inventoryItemId, locationIds, context);
        return availableQuantity;
    }
    /**
     * Retrieves the stocked quantity of a given inventory item in a given location.
     * @param inventoryItemId - the id of the inventory item
     * @param locationIds - the ids of the locations to check
     * @param context
     * @return The stocked quantity
     * @throws when the inventory item is not found
     */
    async retrieveStockedQuantity(inventoryItemId, locationIds, context = {}) {
        // Throws if item does not exist
        await this.inventoryItemService_.retrieve(inventoryItemId, {
            select: ["id"],
        }, context);
        if (locationIds.length === 0) {
            return 0;
        }
        const stockedQuantity = await this.inventoryLevelService_.getStockedQuantity(inventoryItemId, locationIds, context);
        return stockedQuantity;
    }
    /**
     * Retrieves the reserved quantity of a given inventory item in a given location.
     * @param inventoryItemId - the id of the inventory item
     * @param locationIds - the ids of the locations to check
     * @param context
     * @return The reserved quantity
     * @throws when the inventory item is not found
     */
    async retrieveReservedQuantity(inventoryItemId, locationIds, context = {}) {
        // Throws if item does not exist
        await this.inventoryItemService_.retrieve(inventoryItemId, {
            select: ["id"],
        }, context);
        if (locationIds.length === 0) {
            return 0;
        }
        const reservedQuantity = await this.inventoryLevelService_.getReservedQuantity(inventoryItemId, locationIds, context);
        return reservedQuantity;
    }
    /**
     * Confirms whether there is sufficient inventory for a given quantity of a given inventory item in a given location.
     * @param inventoryItemId - the id of the inventory item
     * @param locationIds - the ids of the locations to check
     * @param quantity - the quantity to check
     * @param context
     * @return Whether there is sufficient inventory
     */
    async confirmInventory(inventoryItemId, locationIds, quantity, context = {}) {
        const availableQuantity = await this.retrieveAvailableQuantity(inventoryItemId, locationIds, context);
        return availableQuantity >= quantity;
    }
}
exports.default = InventoryService;
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "listInventoryItems", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "list", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "listInventoryLevels", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "listReservationItems", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "retrieveInventoryItem", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "retrieveInventoryLevel", null);
__decorate([
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "retrieveReservationItem", null);
__decorate([
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "ensureInventoryLevels", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "createReservationItems", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "createReservationItem", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "createInventoryItems", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "createInventoryItem", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "createInventoryLevels", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "createInventoryLevel", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "updateInventoryItem", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "deleteInventoryItem", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "restoreInventoryItem", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "deleteInventoryItemLevelByLocationId", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "deleteReservationItemByLocationId", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "deleteInventoryLevel", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "updateInventoryLevels", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(3, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "updateInventoryLevel", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "updateReservationItem", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "deleteReservationItemsByLineItem", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "deleteReservationItem", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(3, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "adjustInventory", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Array, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "retrieveAvailableQuantity", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Array, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "retrieveStockedQuantity", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Array, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "retrieveReservedQuantity", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(3, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Array, Number, Object]),
    __metadata("design:returntype", Promise)
], InventoryService.prototype, "confirmInventory", null);
//# sourceMappingURL=inventory.js.map