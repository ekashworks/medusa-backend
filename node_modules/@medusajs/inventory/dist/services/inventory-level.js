"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@medusajs/utils");
const typeorm_1 = require("typeorm");
const models_1 = require("../models");
const build_query_1 = require("../utils/build-query");
class InventoryLevelService {
    constructor({ eventBusService, manager }) {
        this.manager_ = manager;
        this.eventBusService_ = eventBusService;
    }
    /**
     * Retrieves a list of inventory levels based on the provided selector and configuration.
     * @param selector - An object containing filterable properties for inventory levels.
     * @param config - An object containing configuration options for the query.
     * @param context
     * @return Array of inventory levels.
     */
    async list(selector = {}, config = { relations: [], skip: 0, take: 10 }, context = {}) {
        const manager = context.transactionManager ?? this.manager_;
        const levelRepository = manager.getRepository(models_1.InventoryLevel);
        const query = (0, build_query_1.buildQuery)(selector, config);
        return await levelRepository.find(query);
    }
    /**
     * Retrieves a list of inventory levels and a count based on the provided selector and configuration.
     * @param selector - An object containing filterable properties for inventory levels.
     * @param config - An object containing configuration options for the query.
     * @param context
     * @return An array of inventory levels and a count.
     */
    async listAndCount(selector = {}, config = { relations: [], skip: 0, take: 10 }, context = {}) {
        const manager = context.transactionManager ?? this.manager_;
        const levelRepository = manager.getRepository(models_1.InventoryLevel);
        const query = (0, build_query_1.buildQuery)(selector, config);
        return await levelRepository.findAndCount(query);
    }
    /**
     * Retrieves a single inventory level by its ID.
     * @param inventoryLevelId - The ID of the inventory level to retrieve.
     * @param config - An object containing configuration options for the query.
     * @param context
     * @return A inventory level.
     * @throws If the inventory level ID is not defined or the given ID was not found.
     */
    async retrieve(inventoryLevelId, config = {}, context = {}) {
        if (!(0, utils_1.isDefined)(inventoryLevelId)) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `"inventoryLevelId" must be defined`);
        }
        const manager = context.transactionManager ?? this.manager_;
        const levelRepository = manager.getRepository(models_1.InventoryLevel);
        const query = (0, build_query_1.buildQuery)({ id: inventoryLevelId }, config);
        const [inventoryLevel] = await levelRepository.find(query);
        if (!inventoryLevel) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `InventoryLevel with id ${inventoryLevelId} was not found`);
        }
        return inventoryLevel;
    }
    /**
     * Creates a new inventory level.
     * @param data - An object containing the properties for the new inventory level.
     * @param context
     * @return The created inventory level.
     */
    async create(data, context = {}) {
        const manager = context.transactionManager;
        const toCreate = data.map((d) => {
            return {
                location_id: d.location_id,
                inventory_item_id: d.inventory_item_id,
                stocked_quantity: d.stocked_quantity,
                reserved_quantity: d.reserved_quantity,
                incoming_quantity: d.incoming_quantity,
            };
        });
        const levelRepository = manager.getRepository(models_1.InventoryLevel);
        const inventoryLevels = levelRepository.create(toCreate);
        const saved = await levelRepository.save(inventoryLevels);
        await this.eventBusService_?.emit?.(InventoryLevelService.Events.CREATED, {
            ids: saved.map((i) => i.id),
        });
        return saved;
    }
    /**
     * Updates an existing inventory level.
     * @param inventoryLevelId - The ID of the inventory level to update.
     * @param data - An object containing the properties to update on the inventory level.
     * @param context
     * @return The updated inventory level.
     * @throws If the inventory level ID is not defined or the given ID was not found.
     */
    async update(inventoryLevelId, data, context = {}) {
        const manager = context.transactionManager;
        const levelRepository = manager.getRepository(models_1.InventoryLevel);
        const item = await this.retrieve(inventoryLevelId, undefined, context);
        const shouldUpdate = Object.keys(data).some((key) => {
            return item[key] !== data[key];
        });
        if (shouldUpdate) {
            levelRepository.merge(item, data);
            await levelRepository.save(item);
            await this.eventBusService_?.emit?.(InventoryLevelService.Events.UPDATED, {
                id: item.id,
            });
        }
        return item;
    }
    /**
     * Adjust the reserved quantity for an inventory item at a specific location.
     * @param inventoryItemId - The ID of the inventory item.
     * @param locationId - The ID of the location.
     * @param quantity - The quantity to adjust from the reserved quantity.
     * @param context
     */
    async adjustReservedQuantity(inventoryItemId, locationId, quantity, context = {}) {
        const manager = context.transactionManager;
        await manager
            .createQueryBuilder()
            .update(models_1.InventoryLevel)
            .set({ reserved_quantity: () => `reserved_quantity + ${quantity}` })
            .where("inventory_item_id = :inventoryItemId AND location_id = :locationId", { inventoryItemId, locationId })
            .execute();
    }
    /**
     * Deletes inventory levels by inventory Item ID.
     * @param inventoryItemId - The ID or IDs of the inventory item to delete inventory levels for.
     * @param context
     */
    async deleteByInventoryItemId(inventoryItemId, context = {}) {
        const ids = Array.isArray(inventoryItemId)
            ? inventoryItemId
            : [inventoryItemId];
        const manager = context.transactionManager;
        const levelRepository = manager.getRepository(models_1.InventoryLevel);
        await levelRepository.softDelete({ inventory_item_id: (0, typeorm_1.In)(ids) });
        await this.eventBusService_?.emit?.(InventoryLevelService.Events.DELETED, {
            inventory_item_id: inventoryItemId,
        });
    }
    /**
     * Restores inventory levels by inventory Item ID.
     * @param inventoryItemId - The ID or IDs of the inventory item to restore inventory levels for.
     * @param context
     */
    async restoreByInventoryItemId(inventoryItemId, context = {}) {
        const ids = Array.isArray(inventoryItemId)
            ? inventoryItemId
            : [inventoryItemId];
        const manager = context.transactionManager;
        const levelRepository = manager.getRepository(models_1.InventoryLevel);
        await levelRepository.restore({ inventory_item_id: (0, typeorm_1.In)(ids) });
        await this.eventBusService_?.emit?.(InventoryLevelService.Events.RESTORED, {
            inventory_item_id: inventoryItemId,
        });
    }
    /**
     * Deletes an inventory level by ID.
     * @param inventoryLevelId - The ID or IDs of the inventory level to delete.
     * @param context
     */
    async delete(inventoryLevelId, context = {}) {
        const ids = Array.isArray(inventoryLevelId)
            ? inventoryLevelId
            : [inventoryLevelId];
        const manager = context.transactionManager;
        const levelRepository = manager.getRepository(models_1.InventoryLevel);
        await levelRepository.softDelete({ id: (0, typeorm_1.In)(ids) });
        await this.eventBusService_?.emit?.(InventoryLevelService.Events.DELETED, {
            ids: inventoryLevelId,
        });
    }
    /**
     * Deletes inventory levels by location ID.
     * @param locationId - The ID of the location to delete inventory levels for.
     * @param context
     */
    async deleteByLocationId(locationId, context = {}) {
        const manager = context.transactionManager;
        const levelRepository = manager.getRepository(models_1.InventoryLevel);
        const ids = Array.isArray(locationId) ? locationId : [locationId];
        await levelRepository.softDelete({ location_id: (0, typeorm_1.In)(ids) });
        await this.eventBusService_?.emit?.(InventoryLevelService.Events.DELETED, {
            location_ids: ids,
        });
    }
    /**
     * Gets the total stocked quantity for a specific inventory item at multiple locations.
     * @param inventoryItemId - The ID of the inventory item.
     * @param locationIds - The IDs of the locations.
     * @param context
     * @return The total stocked quantity.
     */
    async getStockedQuantity(inventoryItemId, locationIds, context = {}) {
        if (!Array.isArray(locationIds)) {
            locationIds = [locationIds];
        }
        const manager = context.transactionManager ?? this.manager_;
        const levelRepository = manager.getRepository(models_1.InventoryLevel);
        const result = await levelRepository
            .createQueryBuilder()
            .select("SUM(stocked_quantity)", "quantity")
            .where("inventory_item_id = :inventoryItemId", { inventoryItemId })
            .andWhere("location_id IN (:...locationIds)", { locationIds })
            .getRawOne();
        return parseFloat(result.quantity);
    }
    /**
     * Gets the total available quantity for a specific inventory item at multiple locations.
     * @param inventoryItemId - The ID of the inventory item.
     * @param locationIds - The IDs of the locations.
     * @param context
     * @return The total available quantity.
     */
    async getAvailableQuantity(inventoryItemId, locationIds, context = {}) {
        if (!Array.isArray(locationIds)) {
            locationIds = [locationIds];
        }
        const manager = context.transactionManager ?? this.manager_;
        const levelRepository = manager.getRepository(models_1.InventoryLevel);
        const result = await levelRepository
            .createQueryBuilder()
            .select("SUM(stocked_quantity - reserved_quantity)", "quantity")
            .where("inventory_item_id = :inventoryItemId", { inventoryItemId })
            .andWhere("location_id IN (:...locationIds)", { locationIds })
            .getRawOne();
        return parseFloat(result.quantity);
    }
    /**
     * Gets the total reserved quantity for a specific inventory item at multiple locations.
     * @param inventoryItemId - The ID of the inventory item.
     * @param locationIds - The IDs of the locations.
     * @param context
     * @return The total reserved quantity.
     */
    async getReservedQuantity(inventoryItemId, locationIds, context = {}) {
        if (!Array.isArray(locationIds)) {
            locationIds = [locationIds];
        }
        const manager = context.transactionManager ?? this.manager_;
        const levelRepository = manager.getRepository(models_1.InventoryLevel);
        const result = await levelRepository
            .createQueryBuilder()
            .select("SUM(reserved_quantity)", "quantity")
            .where("inventory_item_id = :inventoryItemId", { inventoryItemId })
            .andWhere("location_id IN (:...locationIds)", { locationIds })
            .getRawOne();
        return parseFloat(result.quantity);
    }
}
InventoryLevelService.Events = {
    CREATED: "inventory-level.created",
    UPDATED: "inventory-level.updated",
    DELETED: "inventory-level.deleted",
    RESTORED: "inventory-level.restored",
};
exports.default = InventoryLevelService;
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryLevelService.prototype, "list", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryLevelService.prototype, "listAndCount", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryLevelService.prototype, "retrieve", null);
__decorate([
    (0, utils_1.InjectEntityManager)(),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], InventoryLevelService.prototype, "create", null);
__decorate([
    (0, utils_1.InjectEntityManager)(),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryLevelService.prototype, "update", null);
__decorate([
    (0, utils_1.InjectEntityManager)(),
    __param(3, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number, Object]),
    __metadata("design:returntype", Promise)
], InventoryLevelService.prototype, "adjustReservedQuantity", null);
__decorate([
    (0, utils_1.InjectEntityManager)(),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryLevelService.prototype, "deleteByInventoryItemId", null);
__decorate([
    (0, utils_1.InjectEntityManager)(),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryLevelService.prototype, "restoreByInventoryItemId", null);
__decorate([
    (0, utils_1.InjectEntityManager)(),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryLevelService.prototype, "delete", null);
__decorate([
    (0, utils_1.InjectEntityManager)(),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryLevelService.prototype, "deleteByLocationId", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryLevelService.prototype, "getStockedQuantity", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryLevelService.prototype, "getAvailableQuantity", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], InventoryLevelService.prototype, "getReservedQuantity", null);
//# sourceMappingURL=inventory-level.js.map