"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@medusajs/types");
const utils_1 = require("@medusajs/utils");
const typeorm_1 = require("typeorm");
const joiner_config_1 = require("../joiner-config");
const models_1 = require("../models");
const build_query_1 = require("../utils/build-query");
/**
 * Service for managing stock locations.
 */
class StockLocationService {
    constructor({ eventBusService, manager }, options, moduleDeclaration) {
        this.moduleDeclaration = moduleDeclaration;
        this.manager_ = manager;
        this.eventBusService_ = eventBusService;
    }
    __joinerConfig() {
        return joiner_config_1.joinerConfig;
    }
    /**
     * Lists all stock locations that match the given selector.
     * @param selector - Properties to filter by.
     * @param config - Additional configuration for the query.
     * @param context
     * @return A list of stock locations.
     */
    async list(selector = {}, config = { relations: [], skip: 0, take: 10 }, context = {}) {
        const [locations] = await this.listAndCount(selector, config, context);
        return locations;
    }
    /**
     * Lists all stock locations that match the given selector and returns the count of matching stock locations.
     * @param selector - Properties to filter by.
     * @param config - Additional configuration for the query.
     * @param context
     * @return A list of stock locations and the count of matching stock locations.
     */
    async listAndCount(selector = {}, config = { relations: [], skip: 0, take: 10 }, context = {}) {
        const manager = context.transactionManager ?? this.manager_;
        const locationRepo = manager.getRepository(models_1.StockLocation);
        let q;
        if (selector.q) {
            q = selector.q;
            delete selector.q;
        }
        const query = (0, build_query_1.buildQuery)(selector, config);
        if (q) {
            const where = query.where;
            delete where.name;
            query.where = [
                {
                    ...where,
                    name: (0, typeorm_1.ILike)(`%${q}%`),
                },
            ];
        }
        return await locationRepo.findAndCount(query);
    }
    /**
     * Retrieves a Stock Location by its ID.
     * @param stockLocationId - The ID of the stock location.
     * @param config - Additional configuration for the query.
     * @param context
     * @return The stock location.
     * @throws If the stock location ID is not definedor the stock location with the given ID was not found.
     */
    async retrieve(stockLocationId, config = {}, context = {}) {
        if (!(0, utils_1.isDefined)(stockLocationId)) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `"stockLocationId" must be defined`);
        }
        const manager = context.transactionManager ?? this.manager_;
        const locationRepo = manager.getRepository(models_1.StockLocation);
        const query = (0, build_query_1.buildQuery)({ id: stockLocationId }, config);
        const [loc] = await locationRepo.find(query);
        if (!loc) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `StockLocation with id ${stockLocationId} was not found`);
        }
        return loc;
    }
    /**
     * Creates a new stock location.
     * @param data - The input data for creating a Stock Location.
     * @param context
     * @returns The created stock location.
     */
    async create(data, context = {}) {
        const manager = context.transactionManager;
        const locationRepo = manager.getRepository(models_1.StockLocation);
        const loc = locationRepo.create({
            name: data.name,
        });
        if ((0, utils_1.isDefined)(data.address) || (0, utils_1.isDefined)(data.address_id)) {
            if (typeof data.address === "string" || data.address_id) {
                const addrId = (data.address ?? data.address_id);
                loc.address_id = addrId;
            }
            else {
                const locAddressRepo = manager.getRepository(models_1.StockLocationAddress);
                const locAddress = locAddressRepo.create(data.address);
                const addressResult = await locAddressRepo.save(locAddress);
                loc.address_id = addressResult.id;
            }
        }
        const { metadata } = data;
        if (metadata) {
            loc.metadata = (0, utils_1.setMetadata)(loc, metadata);
        }
        const result = await locationRepo.save(loc);
        await this.eventBusService_?.emit?.(StockLocationService.Events.CREATED, {
            id: result.id,
        });
        return result;
    }
    /**
     * Updates an existing stock location.
     * @param stockLocationId - The ID of the stock location to update.
     * @param updateData - The update data for the stock location.
     * @param context
     * @returns The updated stock location.
     */
    async update(stockLocationId, updateData, context = {}) {
        const manager = context.transactionManager;
        const locationRepo = manager.getRepository(models_1.StockLocation);
        const item = await this.retrieve(stockLocationId, undefined, context);
        const { address, ...data } = updateData;
        if (address) {
            if (item.address_id) {
                await this.updateAddress(item.address_id, address, context);
            }
            else {
                const locAddressRepo = manager.getRepository(models_1.StockLocationAddress);
                const locAddress = locAddressRepo.create(address);
                const addressResult = await locAddressRepo.save(locAddress);
                data.address_id = addressResult.id;
            }
        }
        const { metadata, ...fields } = data;
        const toSave = locationRepo.merge(item, fields);
        if (metadata) {
            toSave.metadata = (0, utils_1.setMetadata)(toSave, metadata);
        }
        await locationRepo.save(toSave);
        await this.eventBusService_?.emit?.(StockLocationService.Events.UPDATED, {
            id: stockLocationId,
        });
        return item;
    }
    /**
     * Updates an address for a Stock Location.
     * @param addressId - The ID of the address to update.
     * @param address - The update data for the address.
     * @param context
     * @returns The updated stock location address.
     */
    async updateAddress(addressId, address, context = {}) {
        if (!(0, utils_1.isDefined)(addressId)) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `"addressId" must be defined`);
        }
        const manager = context.transactionManager;
        const locationAddressRepo = manager.getRepository(models_1.StockLocationAddress);
        const existingAddress = await locationAddressRepo.findOne({
            where: { id: addressId },
        });
        if (!existingAddress) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.NOT_FOUND, `StockLocation address with id ${addressId} was not found`);
        }
        const { metadata, ...fields } = address;
        const toSave = locationAddressRepo.merge(existingAddress, fields);
        if (metadata) {
            toSave.metadata = (0, utils_1.setMetadata)(toSave, metadata);
        }
        return await locationAddressRepo.save(toSave);
    }
    /**
     * Deletes a Stock Location.
     * @param id - The ID of the stock location to delete.
     * @param context
     * @returns An empty promise.
     */
    async delete(id, context = {}) {
        const manager = context.transactionManager;
        const locationRepo = manager.getRepository(models_1.StockLocation);
        await locationRepo.softRemove({ id });
        await this.eventBusService_?.emit?.(StockLocationService.Events.DELETED, {
            id,
        });
    }
}
StockLocationService.Events = {
    CREATED: "stock-location.created",
    UPDATED: "stock-location.updated",
    DELETED: "stock-location.deleted",
};
exports.default = StockLocationService;
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], StockLocationService.prototype, "list", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], StockLocationService.prototype, "listAndCount", null);
__decorate([
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], StockLocationService.prototype, "retrieve", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], StockLocationService.prototype, "create", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], StockLocationService.prototype, "update", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(2, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], StockLocationService.prototype, "updateAddress", null);
__decorate([
    (0, utils_1.InjectEntityManager)((target) => target.moduleDeclaration?.resources === types_1.MODULE_RESOURCE_TYPE.ISOLATED),
    __param(1, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], StockLocationService.prototype, "delete", null);
//# sourceMappingURL=stock-location.js.map