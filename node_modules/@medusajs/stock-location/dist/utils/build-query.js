"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildQuery = void 0;
const typeorm_1 = require("typeorm");
const utils_1 = require("@medusajs/utils");
const operatorsMap = {
    lt: (value) => (0, typeorm_1.LessThan)(value),
    gt: (value) => (0, typeorm_1.MoreThan)(value),
    lte: (value) => (0, typeorm_1.LessThanOrEqual)(value),
    gte: (value) => (0, typeorm_1.MoreThanOrEqual)(value),
    contains: (value) => (0, typeorm_1.ILike)(`%${value}%`),
    starts_with: (value) => (0, typeorm_1.ILike)(`${value}%`),
    ends_with: (value) => (0, typeorm_1.ILike)(`%${value}`),
};
/**
 * Used to build TypeORM queries.
 * @param selector The selector
 * @param config The config
 * @return The QueryBuilderConfig
 */
function buildQuery(selector, config = {}) {
    const query = {
        where: buildWhere(selector),
    };
    if ("deleted_at" in selector) {
        query.withDeleted = true;
    }
    if ("skip" in config) {
        ;
        query.skip = config.skip ?? undefined;
    }
    if ("take" in config) {
        ;
        query.take = config.take ?? undefined;
    }
    if (config.relations) {
        query.relations = (0, utils_1.buildRelations)(config.relations);
    }
    if (config.select) {
        query.select = (0, utils_1.buildSelects)(config.select);
    }
    if (config.order) {
        query.order = (0, utils_1.buildOrder)(config.order);
    }
    return query;
}
exports.buildQuery = buildQuery;
/**
 * @param constraints
 *
 * @example
 * const q = buildWhere(
 *   {
 *     id: "1234",
 *     test1: ["123", "12", "1"],
 *     test2: Not("this"),
 *     date: { gt: date },
 *     amount: { gt: 10 },
 *   },
 *)
 *
 * // Output
 * {
 *    id: "1234",
 *    test1: In(["123", "12", "1"]),
 *    test2: Not("this"),
 *    date: MoreThan(date),
 *    amount: MoreThan(10)
 * }
 */
function buildWhere(constraints) {
    let where = {};
    if (Array.isArray(constraints)) {
        where = [];
        constraints.forEach((constraint) => {
            ;
            where.push(buildWhere(constraint));
        });
        return where;
    }
    for (const [key, value] of Object.entries(constraints)) {
        if (value === undefined) {
            continue;
        }
        if (value === null) {
            where[key] = (0, typeorm_1.IsNull)();
            continue;
        }
        if (value instanceof typeorm_1.FindOperator) {
            where[key] = value;
            continue;
        }
        if (Array.isArray(value)) {
            where[key] = (0, typeorm_1.In)(value);
            continue;
        }
        if (typeof value === "object") {
            Object.entries(value).forEach(([objectKey, objectValue]) => {
                where[key] = where[key] || [];
                if (operatorsMap[objectKey]) {
                    where[key].push(operatorsMap[objectKey](objectValue));
                }
                else {
                    if (objectValue != undefined && typeof objectValue === "object") {
                        where[key] = buildWhere(objectValue);
                        return;
                    }
                    where[key] = value;
                }
                return;
            });
            if (!Array.isArray(where[key])) {
                continue;
            }
            if (where[key].length === 1) {
                where[key] = where[key][0];
            }
            else {
                where[key] = (0, typeorm_1.And)(...where[key]);
            }
            continue;
        }
        where[key] = value;
    }
    return where;
}
//# sourceMappingURL=build-query.js.map